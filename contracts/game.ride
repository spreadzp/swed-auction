{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}


{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let startRoundHeight = 5

func randomizer(inv: Invocation) = {
    let lastPlay = match getBinary(this, "lastPlay") {
        case s:ByteVector => s
        case a:Unit => base64'V2F2ZXNMb3R0b1Yy'
    }

    let rand = lastPlay + inv.transactionId + inv.callerPublicKey + lastBlock.generationSignature + toBytes(lastBlock.timestamp) + toBytes(lastBlock.height)
    sha256(rand)
}


func getRoundNumber1(inv: Invocation) = {
 
    let playLimit = wavesBalance(this) / 100
    let payment = extract(inv.payment)

    if(!isDefined(inv.payment)) then {
        throw("Should be with Payment in Waves")
    } else if (isDefined(payment.assetId)) then {
        throw("Payment should be in Waves")
    } else if (payment.amount > playLimit) then {
        throw("Payment should be less than " + toString(playLimit))
    } else {

        let randhash = randomizer(inv)
        let winTransfer = TransferSet([ScriptTransfer(inv.caller, payment.amount * 190 / 100, unit)])
        let writeLastPlay = WriteSet([DataEntry("lastPlay", randhash)])

        if(randhash.toInt() % 1000 < 500) then {
            ScriptResult(writeLastPlay, winTransfer)
        } else {
            ScriptResult(writeLastPlay, TransferSet([]))
        }
    }
} 

func getWinnersPrevRound(currRound: Int, isNumberMore: Boolean) = {
  let prevNumberRound = currRound - 1
  if (isNumberMore == true) then
        WriteSet([
        DataEntry("lastRoundWinner", prevNumberRound.toString() + "_more_" ) 
        ] 
      )
      else       
        WriteSet([
        DataEntry("lastRoundWinner", prevNumberRound.toString() + "_less_" ) 
          ] 
        ) 
}

func getCurrentNumberRound() = {
  match getInteger(this, "numberRound") { 
        case a:Int => a
        case _ => 1
      } 
}

func getBet(bet: Int, round: Int, addressGamer: String) =  {
  if(round >= 1 ) then { 
    let winnerOfPrevRound = match getString(this, "lastRoundWinner") {
      case w: String => w
      case _ => ""

    }
    let winnerFromPrevRound = match getString(this, winnerOfPrevRound + addressGamer) {
      case w: String => w
      case _ => ""
    }

    if(round > 1 && winnerFromPrevRound == "") then {
      round * 2
    }
    else
      1
  }
  else 
    1
}

# func checkOppositeRate() = {

# }
func getNumberGame() = {
  match getInteger(this, "numberGame") { 
          case a:Int => a + 1
          case _ => 1
        }
}

@Callable(i)
func startRound() = {
  let newNumberOfRound = match getInteger(this, "numberRound") { 
        case a:Int => a + 1
        case _ => 1
      }
  let randhash = randomizer(i)    
  if(newNumberOfRound == 1 && i.caller == this) then    
    let newNumberGame = getNumberGame()
    WriteSet([DataEntry("numberGame", newNumberGame)])
  else if (newNumberOfRound > 1 && i.caller == this) then
    let isNumberMore = randhash.toInt() % 1000 < 500    
    getWinnersPrevRound(newNumberOfRound, isNumberMore)
  else
      throw("Only owner can start the game.")  
} 


@Callable(i)
func makeBetLess() = {
  let pmt = extract(i.payment)
  let addressGamer = toBase58String(i.caller.bytes)
  let currentRound = getCurrentNumberRound()
  let countBet = getBet(pmt.amount, currentRound, addressGamer)
  if (!isDefined(pmt.assetId) && countBet <= pmt.amount) then
    WriteSet([DataEntry(currentRound.toString() + "_less_" + addressGamer, pmt.amount )])
  else if(countBet > pmt.amount) then {
      throw("Payment must be more for the round!")
  }
  else
    throw("works with waves only")
}

@Callable(i)
func makeBetMore() = {
  let pmt = extract(i.payment)
  let addressGamer = toBase58String(i.caller.bytes)
  let currentRound = getCurrentNumberRound()
  let countBet = getBet(pmt.amount, currentRound, addressGamer)
  if (!isDefined(pmt.assetId) && countBet <= pmt.amount) then
    WriteSet([DataEntry(currentRound.toString() + "_more_" + addressGamer, pmt.amount )])
  else if(countBet > pmt.amount) then {
      throw("Payment must be more for the round!")
  }
  else
    throw("works with waves only")
}
